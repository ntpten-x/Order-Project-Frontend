"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/hooks/useNetworkInterceptors.ts":
/*!*********************************************!*\
  !*** ./src/hooks/useNetworkInterceptors.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useNetworkInterceptors: function() { return /* binding */ useNetworkInterceptors; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/axios */ \"(app-pages-browser)/./src/lib/axios.ts\");\n/* harmony import */ var _contexts_pos_GlobalLoadingContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../contexts/pos/GlobalLoadingContext */ \"(app-pages-browser)/./src/contexts/pos/GlobalLoadingContext.tsx\");\n/* harmony import */ var _utils_pos_csrf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/pos/csrf */ \"(app-pages-browser)/./src/utils/pos/csrf.ts\");\n/* harmony import */ var _utils_network__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/network */ \"(app-pages-browser)/./src/utils/network.ts\");\n/* __next_internal_client_entry_do_not_use__ useNetworkInterceptors auto */ \n\n\n\n\nconst resolveAxiosUrl = (url, baseURL)=>{\n    if (!url && !baseURL) return \"\";\n    if (url && /^https?:\\/\\//i.test(url)) return url;\n    if (baseURL && /^https?:\\/\\//i.test(baseURL)) {\n        return new URL(url || \"\", baseURL).toString();\n    }\n    const base = baseURL ? baseURL.replace(/\\/$/, \"\") : \"\";\n    const path = url ? url.replace(/^\\//, \"\") : \"\";\n    if (!base && !path) return \"\";\n    if (!base) return \"/\".concat(path);\n    if (!path) return base;\n    return \"\".concat(base, \"/\").concat(path);\n};\nconst useNetworkInterceptors = ()=>{\n    const { showLoading, hideLoading, loadingMessage } = (0,_contexts_pos_GlobalLoadingContext__WEBPACK_IMPORTED_MODULE_2__.useGlobalLoading)();\n    const pendingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const timerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const loadingMessageRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(loadingMessage);\n    const offlineNoticeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        loadingMessageRef.current = loadingMessage;\n    }, [\n        loadingMessage\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (false) {}\n        const start = ()=>{\n            pendingRef.current += 1;\n            if (pendingRef.current === 1) {\n                if (timerRef.current) clearTimeout(timerRef.current);\n                timerRef.current = setTimeout(()=>{\n                    if (pendingRef.current > 0) {\n                        showLoading(loadingMessageRef.current ? undefined : \"กำลังโหลดข้อมูล...\", \"network\");\n                    }\n                }, _utils_network__WEBPACK_IMPORTED_MODULE_4__.LOADING_DELAY_MS);\n            }\n        };\n        const stop = ()=>{\n            pendingRef.current = Math.max(0, pendingRef.current - 1);\n            if (pendingRef.current === 0) {\n                if (timerRef.current) {\n                    clearTimeout(timerRef.current);\n                    timerRef.current = null;\n                }\n                hideLoading(\"network\");\n            }\n        };\n        const originalFetch = window.fetch.bind(window);\n        window.fetch = async (input, init)=>{\n            const request = input instanceof Request ? input : null;\n            const url = typeof input === \"string\" ? input : (request === null || request === void 0 ? void 0 : request.url) || \"\";\n            const method = ((init === null || init === void 0 ? void 0 : init.method) || (request === null || request === void 0 ? void 0 : request.method) || \"GET\").toUpperCase();\n            const track = (0,_utils_network__WEBPACK_IMPORTED_MODULE_4__.shouldTrackRequest)(url, init);\n            if (track) start();\n            try {\n                let finalInit = init;\n                if ((0,_utils_network__WEBPACK_IMPORTED_MODULE_4__.shouldAttachCsrf)(url, method, init)) {\n                    const headers = new Headers((init === null || init === void 0 ? void 0 : init.headers) || (request === null || request === void 0 ? void 0 : request.headers) || {});\n                    // Always try to get CSRF token for cookie-based requests\n                    const csrfToken = await (0,_utils_pos_csrf__WEBPACK_IMPORTED_MODULE_3__.getCsrfTokenCached)();\n                    if (csrfToken) {\n                        headers.set(\"X-CSRF-Token\", csrfToken);\n                    } else {\n                        // If token fetch failed, log warning but don't block request\n                        // Backend will reject if CSRF token is required\n                        console.warn(\"[CSRF] Failed to get CSRF token for request:\", method, url);\n                    }\n                    finalInit = {\n                        ...init,\n                        headers\n                    };\n                }\n                return await originalFetch(input, finalInit);\n            } finally{\n                if (track) stop();\n            }\n        };\n        const requestInterceptor = _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].interceptors.request.use(async (config)=>{\n            const url = resolveAxiosUrl(config.url, config.baseURL);\n            const track = url ? (0,_utils_network__WEBPACK_IMPORTED_MODULE_4__.shouldTrackRequest)(url, {\n                headers: config.headers\n            }) : false;\n            config._trackLoading = track;\n            if (track) start();\n            return config;\n        }, (error)=>{\n            const cfg = (error === null || error === void 0 ? void 0 : error.config) || {};\n            if (cfg._trackLoading) stop();\n            return Promise.reject(error);\n        });\n        const responseInterceptor = _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].interceptors.response.use((response)=>{\n            const cfg = response.config || {};\n            if (cfg._trackLoading) stop();\n            return response;\n        }, (error)=>{\n            const cfg = (error === null || error === void 0 ? void 0 : error.config) || {};\n            if (cfg._trackLoading) stop();\n            return Promise.reject(error);\n        });\n        return ()=>{\n            window.fetch = originalFetch;\n            _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].interceptors.request.eject(requestInterceptor);\n            _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].interceptors.response.eject(responseInterceptor);\n            if (timerRef.current) {\n                clearTimeout(timerRef.current);\n                timerRef.current = null;\n            }\n        };\n    }, [\n        showLoading,\n        hideLoading\n    ]);\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VOZXR3b3JrSW50ZXJjZXB0b3JzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7NEVBRTBDO0FBRVg7QUFDeUM7QUFDakI7QUFLN0I7QUFHMUIsTUFBTVEsa0JBQWtCLENBQUNDLEtBQWNDO0lBQ3JDLElBQUksQ0FBQ0QsT0FBTyxDQUFDQyxTQUFTLE9BQU87SUFDN0IsSUFBSUQsT0FBTyxnQkFBZ0JFLElBQUksQ0FBQ0YsTUFBTSxPQUFPQTtJQUM3QyxJQUFJQyxXQUFXLGdCQUFnQkMsSUFBSSxDQUFDRCxVQUFVO1FBQzVDLE9BQU8sSUFBSUUsSUFBSUgsT0FBTyxJQUFJQyxTQUFTRyxRQUFRO0lBQzdDO0lBQ0EsTUFBTUMsT0FBT0osVUFBVUEsUUFBUUssT0FBTyxDQUFDLE9BQU8sTUFBTTtJQUNwRCxNQUFNQyxPQUFPUCxNQUFNQSxJQUFJTSxPQUFPLENBQUMsT0FBTyxNQUFNO0lBQzVDLElBQUksQ0FBQ0QsUUFBUSxDQUFDRSxNQUFNLE9BQU87SUFDM0IsSUFBSSxDQUFDRixNQUFNLE9BQU8sSUFBUyxPQUFMRTtJQUN0QixJQUFJLENBQUNBLE1BQU0sT0FBT0Y7SUFDbEIsT0FBTyxHQUFXRSxPQUFSRixNQUFLLEtBQVEsT0FBTEU7QUFDcEI7QUFFTyxNQUFNQyx5QkFBeUI7SUFDcEMsTUFBTSxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsY0FBYyxFQUFFLEdBQUdqQixvRkFBZ0JBO0lBQ3JFLE1BQU1rQixhQUFhcEIsNkNBQU1BLENBQUM7SUFDMUIsTUFBTXFCLFdBQVdyQiw2Q0FBTUEsQ0FBdUM7SUFDOUQsTUFBTXNCLG9CQUFvQnRCLDZDQUFNQSxDQUFxQm1CO0lBQ3JELE1BQU1JLG1CQUFtQnZCLDZDQUFNQSxDQUFDO0lBRWhDRCxnREFBU0EsQ0FBQztRQUNSdUIsa0JBQWtCRSxPQUFPLEdBQUdMO0lBQzlCLEdBQUc7UUFBQ0E7S0FBZTtJQUVuQnBCLGdEQUFTQSxDQUFDO1FBQ1IsSUFB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QUFRLENBQUNSLEdBQUcsQ0FDdkQsQ0FBQ1E7WUFDQyxNQUFNSixNQUFPSSxTQUFTUCxNQUFNLElBQUksQ0FBQztZQUNqQyxJQUFJRyxJQUFJRixhQUFhLEVBQUV6QjtZQUN2QixPQUFPK0I7UUFDVCxHQUNBLENBQUNMO1lBQ0MsTUFBTUMsTUFBT0QsQ0FBQUEsa0JBQUFBLDRCQUFBQSxNQUFPRixNQUFNLEtBQUksQ0FBQztZQUMvQixJQUFJRyxJQUFJRixhQUFhLEVBQUV6QjtZQUN2QixPQUFPNEIsUUFBUUMsTUFBTSxDQUFDSDtRQUN4QjtRQUdGLE9BQU87WUFDTHRCLE9BQU9DLEtBQUssR0FBR0Y7WUFDZi9CLGtEQUFHQSxDQUFDa0QsWUFBWSxDQUFDYixPQUFPLENBQUN1QixLQUFLLENBQUNYO1lBQy9CakQsa0RBQUdBLENBQUNrRCxZQUFZLENBQUNTLFFBQVEsQ0FBQ0MsS0FBSyxDQUFDRjtZQUNoQyxJQUFJdEMsU0FBU0csT0FBTyxFQUFFO2dCQUNwQkUsYUFBYUwsU0FBU0csT0FBTztnQkFDN0JILFNBQVNHLE9BQU8sR0FBRztZQUNyQjtRQUNGO0lBQ0YsR0FBRztRQUFDUDtRQUFhQztLQUFZO0FBQy9CLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL3VzZU5ldHdvcmtJbnRlcmNlcHRvcnMudHM/N2E3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IG1lc3NhZ2UgfSBmcm9tIFwiYW50ZFwiO1xuaW1wb3J0IGFwaSBmcm9tIFwiLi4vbGliL2F4aW9zXCI7XG5pbXBvcnQgeyB1c2VHbG9iYWxMb2FkaW5nIH0gZnJvbSBcIi4uL2NvbnRleHRzL3Bvcy9HbG9iYWxMb2FkaW5nQ29udGV4dFwiO1xuaW1wb3J0IHsgZ2V0Q3NyZlRva2VuQ2FjaGVkIH0gZnJvbSBcIi4uL3V0aWxzL3Bvcy9jc3JmXCI7XG5pbXBvcnQge1xuICBMT0FESU5HX0RFTEFZX01TLFxuICBzaG91bGRBdHRhY2hDc3JmLFxuICBzaG91bGRUcmFja1JlcXVlc3QsXG59IGZyb20gXCIuLi91dGlscy9uZXR3b3JrXCI7XG5pbXBvcnQgeyB0IH0gZnJvbSBcIi4uL3V0aWxzL2kxOG5cIjtcblxuY29uc3QgcmVzb2x2ZUF4aW9zVXJsID0gKHVybD86IHN0cmluZywgYmFzZVVSTD86IHN0cmluZykgPT4ge1xuICBpZiAoIXVybCAmJiAhYmFzZVVSTCkgcmV0dXJuIFwiXCI7XG4gIGlmICh1cmwgJiYgL15odHRwcz86XFwvXFwvL2kudGVzdCh1cmwpKSByZXR1cm4gdXJsO1xuICBpZiAoYmFzZVVSTCAmJiAvXmh0dHBzPzpcXC9cXC8vaS50ZXN0KGJhc2VVUkwpKSB7XG4gICAgcmV0dXJuIG5ldyBVUkwodXJsIHx8IFwiXCIsIGJhc2VVUkwpLnRvU3RyaW5nKCk7XG4gIH1cbiAgY29uc3QgYmFzZSA9IGJhc2VVUkwgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLyQvLCBcIlwiKSA6IFwiXCI7XG4gIGNvbnN0IHBhdGggPSB1cmwgPyB1cmwucmVwbGFjZSgvXlxcLy8sIFwiXCIpIDogXCJcIjtcbiAgaWYgKCFiYXNlICYmICFwYXRoKSByZXR1cm4gXCJcIjtcbiAgaWYgKCFiYXNlKSByZXR1cm4gYC8ke3BhdGh9YDtcbiAgaWYgKCFwYXRoKSByZXR1cm4gYmFzZTtcbiAgcmV0dXJuIGAke2Jhc2V9LyR7cGF0aH1gO1xufTtcblxuZXhwb3J0IGNvbnN0IHVzZU5ldHdvcmtJbnRlcmNlcHRvcnMgPSAoKSA9PiB7XG4gIGNvbnN0IHsgc2hvd0xvYWRpbmcsIGhpZGVMb2FkaW5nLCBsb2FkaW5nTWVzc2FnZSB9ID0gdXNlR2xvYmFsTG9hZGluZygpO1xuICBjb25zdCBwZW5kaW5nUmVmID0gdXNlUmVmKDApO1xuICBjb25zdCB0aW1lclJlZiA9IHVzZVJlZjxSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IG51bGw+KG51bGwpO1xuICBjb25zdCBsb2FkaW5nTWVzc2FnZVJlZiA9IHVzZVJlZjxzdHJpbmcgfCB1bmRlZmluZWQ+KGxvYWRpbmdNZXNzYWdlKTtcbiAgY29uc3Qgb2ZmbGluZU5vdGljZVJlZiA9IHVzZVJlZigwKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxvYWRpbmdNZXNzYWdlUmVmLmN1cnJlbnQgPSBsb2FkaW5nTWVzc2FnZTtcbiAgfSwgW2xvYWRpbmdNZXNzYWdlXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xuXG4gICAgY29uc3Qgc3RhcnQgPSAoKSA9PiB7XG4gICAgICBwZW5kaW5nUmVmLmN1cnJlbnQgKz0gMTtcbiAgICAgIGlmIChwZW5kaW5nUmVmLmN1cnJlbnQgPT09IDEpIHtcbiAgICAgICAgaWYgKHRpbWVyUmVmLmN1cnJlbnQpIGNsZWFyVGltZW91dCh0aW1lclJlZi5jdXJyZW50KTtcbiAgICAgICAgdGltZXJSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmIChwZW5kaW5nUmVmLmN1cnJlbnQgPiAwKSB7XG4gICAgICAgICAgICBzaG93TG9hZGluZyhsb2FkaW5nTWVzc2FnZVJlZi5jdXJyZW50ID8gdW5kZWZpbmVkIDogXCLguIHguLPguKXguLHguIfguYLguKvguKXguJTguILguYnguK3guKHguLnguKUuLi5cIiwgXCJuZXR3b3JrXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgTE9BRElOR19ERUxBWV9NUyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHN0b3AgPSAoKSA9PiB7XG4gICAgICBwZW5kaW5nUmVmLmN1cnJlbnQgPSBNYXRoLm1heCgwLCBwZW5kaW5nUmVmLmN1cnJlbnQgLSAxKTtcbiAgICAgIGlmIChwZW5kaW5nUmVmLmN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgaWYgKHRpbWVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJSZWYuY3VycmVudCk7XG4gICAgICAgICAgdGltZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZUxvYWRpbmcoXCJuZXR3b3JrXCIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBvcmlnaW5hbEZldGNoID0gd2luZG93LmZldGNoLmJpbmQod2luZG93KTtcblxuICAgIHdpbmRvdy5mZXRjaCA9IGFzeW5jIChpbnB1dDogUmVxdWVzdEluZm8gfCBVUkwsIGluaXQ/OiBSZXF1ZXN0SW5pdCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCA/IGlucHV0IDogbnVsbDtcbiAgICAgIGNvbnN0IHVybCA9IHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIiA/IGlucHV0IDogcmVxdWVzdD8udXJsIHx8IFwiXCI7XG4gICAgICBjb25zdCBtZXRob2QgPSAoaW5pdD8ubWV0aG9kIHx8IHJlcXVlc3Q/Lm1ldGhvZCB8fCBcIkdFVFwiKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgY29uc3QgdHJhY2sgPSBzaG91bGRUcmFja1JlcXVlc3QodXJsLCBpbml0KTtcblxuICAgICAgaWYgKHRyYWNrKSBzdGFydCgpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBsZXQgZmluYWxJbml0ID0gaW5pdDtcbiAgICAgICAgaWYgKHNob3VsZEF0dGFjaENzcmYodXJsLCBtZXRob2QsIGluaXQpKSB7XG4gICAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGluaXQ/LmhlYWRlcnMgfHwgcmVxdWVzdD8uaGVhZGVycyB8fCB7fSk7XG4gICAgICAgICAgLy8gQWx3YXlzIHRyeSB0byBnZXQgQ1NSRiB0b2tlbiBmb3IgY29va2llLWJhc2VkIHJlcXVlc3RzXG4gICAgICAgICAgY29uc3QgY3NyZlRva2VuID0gYXdhaXQgZ2V0Q3NyZlRva2VuQ2FjaGVkKCk7XG4gICAgICAgICAgaWYgKGNzcmZUb2tlbikge1xuICAgICAgICAgICAgaGVhZGVycy5zZXQoXCJYLUNTUkYtVG9rZW5cIiwgY3NyZlRva2VuKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdG9rZW4gZmV0Y2ggZmFpbGVkLCBsb2cgd2FybmluZyBidXQgZG9uJ3QgYmxvY2sgcmVxdWVzdFxuICAgICAgICAgICAgLy8gQmFja2VuZCB3aWxsIHJlamVjdCBpZiBDU1JGIHRva2VuIGlzIHJlcXVpcmVkXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbQ1NSRl0gRmFpbGVkIHRvIGdldCBDU1JGIHRva2VuIGZvciByZXF1ZXN0OlwiLCBtZXRob2QsIHVybCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbmFsSW5pdCA9IHsgLi4uaW5pdCwgaGVhZGVycyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBvcmlnaW5hbEZldGNoKGlucHV0LCBmaW5hbEluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRyYWNrKSBzdG9wKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHJlcXVlc3RJbnRlcmNlcHRvciA9IGFwaS5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoXG4gICAgICBhc3luYyAoY29uZmlnKSA9PiB7XG4gICAgICAgIGNvbnN0IHVybCA9IHJlc29sdmVBeGlvc1VybChjb25maWcudXJsLCBjb25maWcuYmFzZVVSTCk7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gdXJsID8gc2hvdWxkVHJhY2tSZXF1ZXN0KHVybCwgeyBoZWFkZXJzOiBjb25maWcuaGVhZGVycyB9KSA6IGZhbHNlO1xuICAgICAgICAoY29uZmlnIGFzIHsgX3RyYWNrTG9hZGluZz86IGJvb2xlYW4gfSkuX3RyYWNrTG9hZGluZyA9IHRyYWNrO1xuICAgICAgICBpZiAodHJhY2spIHN0YXJ0KCk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgICB9LFxuICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgIGNvbnN0IGNmZyA9IChlcnJvcj8uY29uZmlnIHx8IHt9KSBhcyB7IF90cmFja0xvYWRpbmc/OiBib29sZWFuIH07XG4gICAgICAgIGlmIChjZmcuX3RyYWNrTG9hZGluZykgc3RvcCgpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgICk7XG5cbiAgICBjb25zdCByZXNwb25zZUludGVyY2VwdG9yID0gYXBpLmludGVyY2VwdG9ycy5yZXNwb25zZS51c2UoXG4gICAgICAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgY29uc3QgY2ZnID0gKHJlc3BvbnNlLmNvbmZpZyB8fCB7fSkgYXMgeyBfdHJhY2tMb2FkaW5nPzogYm9vbGVhbiB9O1xuICAgICAgICBpZiAoY2ZnLl90cmFja0xvYWRpbmcpIHN0b3AoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfSxcbiAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICBjb25zdCBjZmcgPSAoZXJyb3I/LmNvbmZpZyB8fCB7fSkgYXMgeyBfdHJhY2tMb2FkaW5nPzogYm9vbGVhbiB9O1xuICAgICAgICBpZiAoY2ZnLl90cmFja0xvYWRpbmcpIHN0b3AoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5mZXRjaCA9IG9yaWdpbmFsRmV0Y2g7XG4gICAgICBhcGkuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZWplY3QocmVxdWVzdEludGVyY2VwdG9yKTtcbiAgICAgIGFwaS5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZWplY3QocmVzcG9uc2VJbnRlcmNlcHRvcik7XG4gICAgICBpZiAodGltZXJSZWYuY3VycmVudCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXJSZWYuY3VycmVudCk7XG4gICAgICAgIHRpbWVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtzaG93TG9hZGluZywgaGlkZUxvYWRpbmddKTtcbn07XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwiYXBpIiwidXNlR2xvYmFsTG9hZGluZyIsImdldENzcmZUb2tlbkNhY2hlZCIsIkxPQURJTkdfREVMQVlfTVMiLCJzaG91bGRBdHRhY2hDc3JmIiwic2hvdWxkVHJhY2tSZXF1ZXN0IiwicmVzb2x2ZUF4aW9zVXJsIiwidXJsIiwiYmFzZVVSTCIsInRlc3QiLCJVUkwiLCJ0b1N0cmluZyIsImJhc2UiLCJyZXBsYWNlIiwicGF0aCIsInVzZU5ldHdvcmtJbnRlcmNlcHRvcnMiLCJzaG93TG9hZGluZyIsImhpZGVMb2FkaW5nIiwibG9hZGluZ01lc3NhZ2UiLCJwZW5kaW5nUmVmIiwidGltZXJSZWYiLCJsb2FkaW5nTWVzc2FnZVJlZiIsIm9mZmxpbmVOb3RpY2VSZWYiLCJjdXJyZW50Iiwic3RhcnQiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwidW5kZWZpbmVkIiwic3RvcCIsIk1hdGgiLCJtYXgiLCJvcmlnaW5hbEZldGNoIiwid2luZG93IiwiZmV0Y2giLCJiaW5kIiwiaW5wdXQiLCJpbml0IiwicmVxdWVzdCIsIlJlcXVlc3QiLCJtZXRob2QiLCJ0b1VwcGVyQ2FzZSIsInRyYWNrIiwiZmluYWxJbml0IiwiaGVhZGVycyIsIkhlYWRlcnMiLCJjc3JmVG9rZW4iLCJzZXQiLCJjb25zb2xlIiwid2FybiIsInJlcXVlc3RJbnRlcmNlcHRvciIsImludGVyY2VwdG9ycyIsInVzZSIsImNvbmZpZyIsIl90cmFja0xvYWRpbmciLCJlcnJvciIsImNmZyIsIlByb21pc2UiLCJyZWplY3QiLCJyZXNwb25zZUludGVyY2VwdG9yIiwicmVzcG9uc2UiLCJlamVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useNetworkInterceptors.ts\n"));

/***/ })

});