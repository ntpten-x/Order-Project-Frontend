"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/hooks/useNetworkInterceptors.ts":
/*!*********************************************!*\
  !*** ./src/hooks/useNetworkInterceptors.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useNetworkInterceptors: function() { return /* binding */ useNetworkInterceptors; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _barrel_optimize_names_message_antd__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=message!=!antd */ \"(app-pages-browser)/./node_modules/antd/es/message/index.js\");\n/* harmony import */ var _lib_axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/axios */ \"(app-pages-browser)/./src/lib/axios.ts\");\n/* harmony import */ var _contexts_pos_GlobalLoadingContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../contexts/pos/GlobalLoadingContext */ \"(app-pages-browser)/./src/contexts/pos/GlobalLoadingContext.tsx\");\n/* harmony import */ var _utils_pos_csrf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/pos/csrf */ \"(app-pages-browser)/./src/utils/pos/csrf.ts\");\n/* harmony import */ var _utils_network__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/network */ \"(app-pages-browser)/./src/utils/network.ts\");\n/* harmony import */ var _utils_i18n__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/i18n */ \"(app-pages-browser)/./src/utils/i18n.ts\");\n/* __next_internal_client_entry_do_not_use__ useNetworkInterceptors auto */ \n\n\n\n\n\n\nconst resolveAxiosUrl = (url, baseURL)=>{\n    if (!url && !baseURL) return \"\";\n    if (url && /^https?:\\/\\//i.test(url)) return url;\n    if (baseURL && /^https?:\\/\\//i.test(baseURL)) {\n        return new URL(url || \"\", baseURL).toString();\n    }\n    const base = baseURL ? baseURL.replace(/\\/$/, \"\") : \"\";\n    const path = url ? url.replace(/^\\//, \"\") : \"\";\n    if (!base && !path) return \"\";\n    if (!base) return \"/\".concat(path);\n    if (!path) return base;\n    return \"\".concat(base, \"/\").concat(path);\n};\nconst useNetworkInterceptors = ()=>{\n    const { showLoading, hideLoading, loadingMessage } = (0,_contexts_pos_GlobalLoadingContext__WEBPACK_IMPORTED_MODULE_2__.useGlobalLoading)();\n    const pendingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const timerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const loadingMessageRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(loadingMessage);\n    const offlineNoticeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        loadingMessageRef.current = loadingMessage;\n    }, [\n        loadingMessage\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (false) {}\n        const notifyOffline = ()=>{\n            const now = Date.now();\n            if (now - offlineNoticeRef.current < 5000) return;\n            offlineNoticeRef.current = now;\n            _barrel_optimize_names_message_antd__WEBPACK_IMPORTED_MODULE_6__[\"default\"].warning((0,_utils_i18n__WEBPACK_IMPORTED_MODULE_5__.t)(\"network.offline\"));\n        };\n        const start = ()=>{\n            pendingRef.current += 1;\n            if (pendingRef.current === 1) {\n                if (timerRef.current) clearTimeout(timerRef.current);\n                timerRef.current = setTimeout(()=>{\n                    if (pendingRef.current > 0) {\n                        showLoading(loadingMessageRef.current ? undefined : \"กำลังโหลดข้อมูล...\", \"network\");\n                    }\n                }, _utils_network__WEBPACK_IMPORTED_MODULE_4__.LOADING_DELAY_MS);\n            }\n        };\n        const stop = ()=>{\n            pendingRef.current = Math.max(0, pendingRef.current - 1);\n            if (pendingRef.current === 0) {\n                if (timerRef.current) {\n                    clearTimeout(timerRef.current);\n                    timerRef.current = null;\n                }\n                hideLoading(\"network\");\n            }\n        };\n        const originalFetch = window.fetch.bind(window);\n        window.fetch = async (input, init)=>{\n            const request = input instanceof Request ? input : null;\n            const url = typeof input === \"string\" ? input : (request === null || request === void 0 ? void 0 : request.url) || \"\";\n            const method = ((init === null || init === void 0 ? void 0 : init.method) || (request === null || request === void 0 ? void 0 : request.method) || \"GET\").toUpperCase();\n            const track = (0,_utils_network__WEBPACK_IMPORTED_MODULE_4__.shouldTrackRequest)(url, init);\n            if (track) start();\n            try {\n                let finalInit = init;\n                if ((0,_utils_network__WEBPACK_IMPORTED_MODULE_4__.shouldAttachCsrf)(url, method, init)) {\n                    const headers = new Headers((init === null || init === void 0 ? void 0 : init.headers) || (request === null || request === void 0 ? void 0 : request.headers) || {});\n                    // Always try to get CSRF token for cookie-based requests\n                    const csrfToken = await (0,_utils_pos_csrf__WEBPACK_IMPORTED_MODULE_3__.getCsrfTokenCached)();\n                    if (csrfToken) {\n                        headers.set(\"X-CSRF-Token\", csrfToken);\n                    } else {\n                        // If token fetch failed, log warning but don't block request\n                        // Backend will reject if CSRF token is required\n                        console.warn(\"[CSRF] Failed to get CSRF token for request:\", method, url);\n                    }\n                    finalInit = {\n                        ...init,\n                        headers\n                    };\n                }\n                return await originalFetch(input, finalInit);\n            } finally{\n                if (track) stop();\n            }\n        };\n        const requestInterceptor = _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].interceptors.request.use(async (config)=>{\n            const url = resolveAxiosUrl(config.url, config.baseURL);\n            const track = url ? (0,_utils_network__WEBPACK_IMPORTED_MODULE_4__.shouldTrackRequest)(url, {\n                headers: config.headers\n            }) : false;\n            config._trackLoading = track;\n            if (track) start();\n            return config;\n        }, (error)=>{\n            const cfg = (error === null || error === void 0 ? void 0 : error.config) || {};\n            if (cfg._trackLoading) stop();\n            return Promise.reject(error);\n        });\n        const responseInterceptor = _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].interceptors.response.use((response)=>{\n            const cfg = response.config || {};\n            if (cfg._trackLoading) stop();\n            return response;\n        }, (error)=>{\n            const cfg = (error === null || error === void 0 ? void 0 : error.config) || {};\n            if (cfg._trackLoading) stop();\n            return Promise.reject(error);\n        });\n        return ()=>{\n            window.fetch = originalFetch;\n            _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].interceptors.request.eject(requestInterceptor);\n            _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].interceptors.response.eject(responseInterceptor);\n            if (timerRef.current) {\n                clearTimeout(timerRef.current);\n                timerRef.current = null;\n            }\n        };\n    }, [\n        showLoading,\n        hideLoading\n    ]);\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VOZXR3b3JrSW50ZXJjZXB0b3JzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs0RUFFMEM7QUFDWDtBQUNBO0FBQ3lDO0FBQ2pCO0FBSzdCO0FBQ1E7QUFFbEMsTUFBTVUsa0JBQWtCLENBQUNDLEtBQWNDO0lBQ3JDLElBQUksQ0FBQ0QsT0FBTyxDQUFDQyxTQUFTLE9BQU87SUFDN0IsSUFBSUQsT0FBTyxnQkFBZ0JFLElBQUksQ0FBQ0YsTUFBTSxPQUFPQTtJQUM3QyxJQUFJQyxXQUFXLGdCQUFnQkMsSUFBSSxDQUFDRCxVQUFVO1FBQzVDLE9BQU8sSUFBSUUsSUFBSUgsT0FBTyxJQUFJQyxTQUFTRyxRQUFRO0lBQzdDO0lBQ0EsTUFBTUMsT0FBT0osVUFBVUEsUUFBUUssT0FBTyxDQUFDLE9BQU8sTUFBTTtJQUNwRCxNQUFNQyxPQUFPUCxNQUFNQSxJQUFJTSxPQUFPLENBQUMsT0FBTyxNQUFNO0lBQzVDLElBQUksQ0FBQ0QsUUFBUSxDQUFDRSxNQUFNLE9BQU87SUFDM0IsSUFBSSxDQUFDRixNQUFNLE9BQU8sSUFBUyxPQUFMRTtJQUN0QixJQUFJLENBQUNBLE1BQU0sT0FBT0Y7SUFDbEIsT0FBTyxHQUFXRSxPQUFSRixNQUFLLEtBQVEsT0FBTEU7QUFDcEI7QUFFTyxNQUFNQyx5QkFBeUI7SUFDcEMsTUFBTSxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsY0FBYyxFQUFFLEdBQUdsQixvRkFBZ0JBO0lBQ3JFLE1BQU1tQixhQUFhdEIsNkNBQU1BLENBQUM7SUFDMUIsTUFBTXVCLFdBQVd2Qiw2Q0FBTUEsQ0FBdUM7SUFDOUQsTUFBTXdCLG9CQUFvQnhCLDZDQUFNQSxDQUFxQnFCO0lBQ3JELE1BQU1JLG1CQUFtQnpCLDZDQUFNQSxDQUFDO0lBRWhDRCxnREFBU0EsQ0FBQztRQUNSeUIsa0JBQWtCRSxPQUFPLEdBQUdMO0lBQzlCLEdBQUc7UUFBQ0E7S0FBZTtJQUVuQnRCLGdEQUFTQSxD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QUNBLENBQUNFO1lBQ0MsTUFBTUMsTUFBT0QsQ0FBQUEsa0JBQUFBLDRCQUFBQSxNQUFPRixNQUFNLEtBQUksQ0FBQztZQUMvQixJQUFJRyxJQUFJRixhQUFhLEVBQUV6QjtZQUN2QixPQUFPNEIsUUFBUUMsTUFBTSxDQUFDSDtRQUN4QjtRQUdGLE1BQU1JLHNCQUFzQi9ELGtEQUFHQSxDQUFDdUQsWUFBWSxDQUFDUyxRQUFRLENBQUNSLEdBQUcsQ0FDdkQsQ0FBQ1E7WUFDQyxNQUFNSixNQUFPSSxTQUFTUCxNQUFNLElBQUksQ0FBQztZQUNqQyxJQUFJRyxJQUFJRixhQUFhLEVBQUV6QjtZQUN2QixPQUFPK0I7UUFDVCxHQUNBLENBQUNMO1lBQ0MsTUFBTUMsTUFBT0QsQ0FBQUEsa0JBQUFBLDRCQUFBQSxNQUFPRixNQUFNLEtBQUksQ0FBQztZQUMvQixJQUFJRyxJQUFJRixhQUFhLEVBQUV6QjtZQUN2QixPQUFPNEIsUUFBUUMsTUFBTSxDQUFDSDtRQUN4QjtRQUdGLE9BQU87WUFDTHRCLE9BQU9DLEtBQUssR0FBR0Y7WUFDZnBDLGtEQUFHQSxDQUFDdUQsWUFBWSxDQUFDYixPQUFPLENBQUN1QixLQUFLLENBQUNYO1lBQy9CdEQsa0RBQUdBLENBQUN1RCxZQUFZLENBQUNTLFFBQVEsQ0FBQ0MsS0FBSyxDQUFDRjtZQUNoQyxJQUFJMUMsU0FBU0csT0FBTyxFQUFFO2dCQUNwQk0sYUFBYVQsU0FBU0csT0FBTztnQkFDN0JILFNBQVNHLE9BQU8sR0FBRztZQUNyQjtRQUNGO0lBQ0YsR0FBRztRQUFDUDtRQUFhQztLQUFZO0FBQy9CLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL3VzZU5ldHdvcmtJbnRlcmNlcHRvcnMudHM/N2E3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IG1lc3NhZ2UgfSBmcm9tIFwiYW50ZFwiO1xuaW1wb3J0IGFwaSBmcm9tIFwiLi4vbGliL2F4aW9zXCI7XG5pbXBvcnQgeyB1c2VHbG9iYWxMb2FkaW5nIH0gZnJvbSBcIi4uL2NvbnRleHRzL3Bvcy9HbG9iYWxMb2FkaW5nQ29udGV4dFwiO1xuaW1wb3J0IHsgZ2V0Q3NyZlRva2VuQ2FjaGVkIH0gZnJvbSBcIi4uL3V0aWxzL3Bvcy9jc3JmXCI7XG5pbXBvcnQge1xuICBMT0FESU5HX0RFTEFZX01TLFxuICBzaG91bGRBdHRhY2hDc3JmLFxuICBzaG91bGRUcmFja1JlcXVlc3QsXG59IGZyb20gXCIuLi91dGlscy9uZXR3b3JrXCI7XG5pbXBvcnQgeyB0IH0gZnJvbSBcIi4uL3V0aWxzL2kxOG5cIjtcblxuY29uc3QgcmVzb2x2ZUF4aW9zVXJsID0gKHVybD86IHN0cmluZywgYmFzZVVSTD86IHN0cmluZykgPT4ge1xuICBpZiAoIXVybCAmJiAhYmFzZVVSTCkgcmV0dXJuIFwiXCI7XG4gIGlmICh1cmwgJiYgL15odHRwcz86XFwvXFwvL2kudGVzdCh1cmwpKSByZXR1cm4gdXJsO1xuICBpZiAoYmFzZVVSTCAmJiAvXmh0dHBzPzpcXC9cXC8vaS50ZXN0KGJhc2VVUkwpKSB7XG4gICAgcmV0dXJuIG5ldyBVUkwodXJsIHx8IFwiXCIsIGJhc2VVUkwpLnRvU3RyaW5nKCk7XG4gIH1cbiAgY29uc3QgYmFzZSA9IGJhc2VVUkwgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLyQvLCBcIlwiKSA6IFwiXCI7XG4gIGNvbnN0IHBhdGggPSB1cmwgPyB1cmwucmVwbGFjZSgvXlxcLy8sIFwiXCIpIDogXCJcIjtcbiAgaWYgKCFiYXNlICYmICFwYXRoKSByZXR1cm4gXCJcIjtcbiAgaWYgKCFiYXNlKSByZXR1cm4gYC8ke3BhdGh9YDtcbiAgaWYgKCFwYXRoKSByZXR1cm4gYmFzZTtcbiAgcmV0dXJuIGAke2Jhc2V9LyR7cGF0aH1gO1xufTtcblxuZXhwb3J0IGNvbnN0IHVzZU5ldHdvcmtJbnRlcmNlcHRvcnMgPSAoKSA9PiB7XG4gIGNvbnN0IHsgc2hvd0xvYWRpbmcsIGhpZGVMb2FkaW5nLCBsb2FkaW5nTWVzc2FnZSB9ID0gdXNlR2xvYmFsTG9hZGluZygpO1xuICBjb25zdCBwZW5kaW5nUmVmID0gdXNlUmVmKDApO1xuICBjb25zdCB0aW1lclJlZiA9IHVzZVJlZjxSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IG51bGw+KG51bGwpO1xuICBjb25zdCBsb2FkaW5nTWVzc2FnZVJlZiA9IHVzZVJlZjxzdHJpbmcgfCB1bmRlZmluZWQ+KGxvYWRpbmdNZXNzYWdlKTtcbiAgY29uc3Qgb2ZmbGluZU5vdGljZVJlZiA9IHVzZVJlZigwKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxvYWRpbmdNZXNzYWdlUmVmLmN1cnJlbnQgPSBsb2FkaW5nTWVzc2FnZTtcbiAgfSwgW2xvYWRpbmdNZXNzYWdlXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xuXG4gICAgY29uc3Qgbm90aWZ5T2ZmbGluZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICBpZiAobm93IC0gb2ZmbGluZU5vdGljZVJlZi5jdXJyZW50IDwgNTAwMCkgcmV0dXJuO1xuICAgICAgb2ZmbGluZU5vdGljZVJlZi5jdXJyZW50ID0gbm93O1xuICAgICAgbWVzc2FnZS53YXJuaW5nKHQoXCJuZXR3b3JrLm9mZmxpbmVcIikpO1xuICAgIH07XG5cbiAgICBjb25zdCBzdGFydCA9ICgpID0+IHtcbiAgICAgIHBlbmRpbmdSZWYuY3VycmVudCArPSAxO1xuICAgICAgaWYgKHBlbmRpbmdSZWYuY3VycmVudCA9PT0gMSkge1xuICAgICAgICBpZiAodGltZXJSZWYuY3VycmVudCkgY2xlYXJUaW1lb3V0KHRpbWVyUmVmLmN1cnJlbnQpO1xuICAgICAgICB0aW1lclJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHBlbmRpbmdSZWYuY3VycmVudCA+IDApIHtcbiAgICAgICAgICAgIHNob3dMb2FkaW5nKGxvYWRpbmdNZXNzYWdlUmVmLmN1cnJlbnQgPyB1bmRlZmluZWQgOiBcIuC4geC4s+C4peC4seC4h+C5guC4q+C4peC4lOC4guC5ieC4reC4oeC4ueC4pS4uLlwiLCBcIm5ldHdvcmtcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBMT0FESU5HX0RFTEFZX01TKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICAgIHBlbmRpbmdSZWYuY3VycmVudCA9IE1hdGgubWF4KDAsIHBlbmRpbmdSZWYuY3VycmVudCAtIDEpO1xuICAgICAgaWYgKHBlbmRpbmdSZWYuY3VycmVudCA9PT0gMCkge1xuICAgICAgICBpZiAodGltZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lclJlZi5jdXJyZW50KTtcbiAgICAgICAgICB0aW1lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBoaWRlTG9hZGluZyhcIm5ldHdvcmtcIik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG9yaWdpbmFsRmV0Y2ggPSB3aW5kb3cuZmV0Y2guYmluZCh3aW5kb3cpO1xuXG4gICAgd2luZG93LmZldGNoID0gYXN5bmMgKGlucHV0OiBSZXF1ZXN0SW5mbyB8IFVSTCwgaW5pdD86IFJlcXVlc3RJbml0KSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0ID8gaW5wdXQgOiBudWxsO1xuICAgICAgY29uc3QgdXJsID0gdHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiID8gaW5wdXQgOiByZXF1ZXN0Py51cmwgfHwgXCJcIjtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IChpbml0Py5tZXRob2QgfHwgcmVxdWVzdD8ubWV0aG9kIHx8IFwiR0VUXCIpLnRvVXBwZXJDYXNlKCk7XG4gICAgICBjb25zdCB0cmFjayA9IHNob3VsZFRyYWNrUmVxdWVzdCh1cmwsIGluaXQpO1xuXG4gICAgICBpZiAodHJhY2spIHN0YXJ0KCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBmaW5hbEluaXQgPSBpbml0O1xuICAgICAgICBpZiAoc2hvdWxkQXR0YWNoQ3NyZih1cmwsIG1ldGhvZCwgaW5pdCkpIHtcbiAgICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5pdD8uaGVhZGVycyB8fCByZXF1ZXN0Py5oZWFkZXJzIHx8IHt9KTtcbiAgICAgICAgICAvLyBBbHdheXMgdHJ5IHRvIGdldCBDU1JGIHRva2VuIGZvciBjb29raWUtYmFzZWQgcmVxdWVzdHNcbiAgICAgICAgICBjb25zdCBjc3JmVG9rZW4gPSBhd2FpdCBnZXRDc3JmVG9rZW5DYWNoZWQoKTtcbiAgICAgICAgICBpZiAoY3NyZlRva2VuKSB7XG4gICAgICAgICAgICBoZWFkZXJzLnNldChcIlgtQ1NSRi1Ub2tlblwiLCBjc3JmVG9rZW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0b2tlbiBmZXRjaCBmYWlsZWQsIGxvZyB3YXJuaW5nIGJ1dCBkb24ndCBibG9jayByZXF1ZXN0XG4gICAgICAgICAgICAvLyBCYWNrZW5kIHdpbGwgcmVqZWN0IGlmIENTUkYgdG9rZW4gaXMgcmVxdWlyZWRcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltDU1JGXSBGYWlsZWQgdG8gZ2V0IENTUkYgdG9rZW4gZm9yIHJlcXVlc3Q6XCIsIG1ldGhvZCwgdXJsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmluYWxJbml0ID0geyAuLi5pbml0LCBoZWFkZXJzIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IG9yaWdpbmFsRmV0Y2goaW5wdXQsIGZpbmFsSW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodHJhY2spIHN0b3AoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgcmVxdWVzdEludGVyY2VwdG9yID0gYXBpLmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZShcbiAgICAgIGFzeW5jIChjb25maWcpID0+IHtcbiAgICAgICAgY29uc3QgdXJsID0gcmVzb2x2ZUF4aW9zVXJsKGNvbmZpZy51cmwsIGNvbmZpZy5iYXNlVVJMKTtcbiAgICAgICAgY29uc3QgdHJhY2sgPSB1cmwgPyBzaG91bGRUcmFja1JlcXVlc3QodXJsLCB7IGhlYWRlcnM6IGNvbmZpZy5oZWFkZXJzIH0pIDogZmFsc2U7XG4gICAgICAgIChjb25maWcgYXMgeyBfdHJhY2tMb2FkaW5nPzogYm9vbGVhbiB9KS5fdHJhY2tMb2FkaW5nID0gdHJhY2s7XG4gICAgICAgIGlmICh0cmFjaykgc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgIH0sXG4gICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgY29uc3QgY2ZnID0gKGVycm9yPy5jb25maWcgfHwge30pIGFzIHsgX3RyYWNrTG9hZGluZz86IGJvb2xlYW4gfTtcbiAgICAgICAgaWYgKGNmZy5fdHJhY2tMb2FkaW5nKSBzdG9wKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlSW50ZXJjZXB0b3IgPSBhcGkuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLnVzZShcbiAgICAgIChyZXNwb25zZSkgPT4ge1xuICAgICAgICBjb25zdCBjZmcgPSAocmVzcG9uc2UuY29uZmlnIHx8IHt9KSBhcyB7IF90cmFja0xvYWRpbmc/OiBib29sZWFuIH07XG4gICAgICAgIGlmIChjZmcuX3RyYWNrTG9hZGluZykgc3RvcCgpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9LFxuICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgIGNvbnN0IGNmZyA9IChlcnJvcj8uY29uZmlnIHx8IHt9KSBhcyB7IF90cmFja0xvYWRpbmc/OiBib29sZWFuIH07XG4gICAgICAgIGlmIChjZmcuX3RyYWNrTG9hZGluZykgc3RvcCgpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgICk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LmZldGNoID0gb3JpZ2luYWxGZXRjaDtcbiAgICAgIGFwaS5pbnRlcmNlcHRvcnMucmVxdWVzdC5lamVjdChyZXF1ZXN0SW50ZXJjZXB0b3IpO1xuICAgICAgYXBpLmludGVyY2VwdG9ycy5yZXNwb25zZS5lamVjdChyZXNwb25zZUludGVyY2VwdG9yKTtcbiAgICAgIGlmICh0aW1lclJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lclJlZi5jdXJyZW50KTtcbiAgICAgICAgdGltZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3Nob3dMb2FkaW5nLCBoaWRlTG9hZGluZ10pO1xufTtcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJtZXNzYWdlIiwiYXBpIiwidXNlR2xvYmFsTG9hZGluZyIsImdldENzcmZUb2tlbkNhY2hlZCIsIkxPQURJTkdfREVMQVlfTVMiLCJzaG91bGRBdHRhY2hDc3JmIiwic2hvdWxkVHJhY2tSZXF1ZXN0IiwidCIsInJlc29sdmVBeGlvc1VybCIsInVybCIsImJhc2VVUkwiLCJ0ZXN0IiwiVVJMIiwidG9TdHJpbmciLCJiYXNlIiwicmVwbGFjZSIsInBhdGgiLCJ1c2VOZXR3b3JrSW50ZXJjZXB0b3JzIiwic2hvd0xvYWRpbmciLCJoaWRlTG9hZGluZyIsImxvYWRpbmdNZXNzYWdlIiwicGVuZGluZ1JlZiIsInRpbWVyUmVmIiwibG9hZGluZ01lc3NhZ2VSZWYiLCJvZmZsaW5lTm90aWNlUmVmIiwiY3VycmVudCIsIm5vdGlmeU9mZmxpbmUiLCJub3ciLCJEYXRlIiwid2FybmluZyIsInN0YXJ0IiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsInVuZGVmaW5lZCIsInN0b3AiLCJNYXRoIiwibWF4Iiwib3JpZ2luYWxGZXRjaCIsIndpbmRvdyIsImZldGNoIiwiYmluZCIsImlucHV0IiwiaW5pdCIsInJlcXVlc3QiLCJSZXF1ZXN0IiwibWV0aG9kIiwidG9VcHBlckNhc2UiLCJ0cmFjayIsImZpbmFsSW5pdCIsImhlYWRlcnMiLCJIZWFkZXJzIiwiY3NyZlRva2VuIiwic2V0IiwiY29uc29sZSIsIndhcm4iLCJyZXF1ZXN0SW50ZXJjZXB0b3IiLCJpbnRlcmNlcHRvcnMiLCJ1c2UiLCJjb25maWciLCJfdHJhY2tMb2FkaW5nIiwiZXJyb3IiLCJjZmciLCJQcm9taXNlIiwicmVqZWN0IiwicmVzcG9uc2VJbnRlcmNlcHRvciIsInJlc3BvbnNlIiwiZWplY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useNetworkInterceptors.ts\n"));

/***/ })

});