[{"filePath":"E:\\STEDD\\Order-Project-Frontend\\src\\app\\(main)\\items\\page.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":118,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":118,"endColumn":27}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":143,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":143,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5439,5442],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5439,5442],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\n\nimport React, { useEffect, useState } from \"react\";\nimport { Table, Tag, Typography, Card, Space, Button, message, Modal } from \"antd\";\nimport { ReloadOutlined, EditOutlined, StopOutlined, EyeOutlined, ShoppingCartOutlined } from \"@ant-design/icons\";\nimport { Order, OrderStatus } from \"@/types/api/orders\";\nimport EditOrderModal from \"@/components/EditOrderModal\";\nimport OrderDetailModal from \"@/components/OrderDetailModal\";\nimport { useSocket } from \"@/hooks/useSocket\";\nimport { useRouter } from \"next/navigation\";\nimport { useAuth } from \"@/contexts/AuthContext\";\n\nconst { Title, Text } = Typography;\n\nexport default function ItemsPage() {\n  const [orders, setOrders] = useState<Order[]>([]);\n  const [loading, setLoading] = useState(true);\n  const { socket } = useSocket();\n  const router = useRouter();\n  const { user } = useAuth();\n\n  const fetchOrders = async () => {\n    try {\n      setLoading(true);\n      // Use Proxy API to forward cookies\n      const response = await fetch(\"/api/orders\", { cache: \"no-store\", headers: { 'Content-Type': 'application/json' } });\n      if (!response.ok) {\n          throw new Error(\"Failed to fetch orders\");\n      }\n      const data = await response.json();\n      // Filter only pending items (conceptually based on user requirement \"Waiting to buy\")\n      // But typically \"Items\" page might show all, let's filter for PENDING first or show all sorted.\n      // User said \"Pending items\" -> \"Wait to buy\".\n      // Let's show all for now but sorted by date.\n      setOrders(data.filter((order: Order) => order.status === OrderStatus.PENDING));\n    } catch {\n      message.error(\"ไม่สามารถโหลดรายการออเดอร์ได้\");\n    } finally {\n        setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    fetchOrders();\n  }, []);\n\n  useEffect(() => {\n    if (!socket) return;\n\n    // Handle real-time updates without full refetch\n    socket.on(\"orders_updated\", (payload: { action: string, data?: Order, id?: string, orderId?: string }) => {\n        const { action, data, id, orderId } = payload;\n        \n        switch (action) {\n            case \"create\":\n                if (data) {\n                    setOrders(prev => [data, ...prev]);\n                    message.success(\"มีออเดอร์ใหม่เข้ามา\");\n                }\n                break;\n            case \"update_status\":\n                if (data) {\n                    setOrders(prev => prev.map(order => order.id === data.id ? data : order));\n                    message.info(`อัปเดตสถานะออเดอร์ ${data.id.substring(0,8)}`);\n                }\n                break;\n            case \"delete\":\n                if (id) {\n                    setOrders(prev => prev.filter(order => order.id !== id));\n                    message.warning(\"ลบออเดอร์แล้ว\");\n                }\n                break;\n            case \"update_item_detail\":\n                 // For item detail updates, we might need to update the specific item inside the order.\n                 // The payload data is OrdersDetail, but the UI shows OrdersItems.\n                 // Since OrdersDetail is linked to OrdersItem, and we likely need to refresh the whole order structure or update carefully.\n                 // For simplicity and accuracy of nested relations, functionality: \"Refetch specific order or all\" is safer.\n                 // Let's refetch all for complex nested updates to avoid consistency issues, OR refetch just that order.\n                 if (orderId) {\n                     // Optimistic update is hard for deep nested without full object. \n                     // Let's refetch to be safe for this complex case, but keep others optimistic.\n                     fetchOrders(); \n                 }\n                 break;\n            default:\n                fetchOrders();\n                break;\n        }\n    });\n\n    return () => {\n        socket.off(\"orders_updated\");\n    };\n  }, [socket]);\n\n  // ... inside component ...\n  const [editingOrder, setEditingOrder] = useState<Order | null>(null);\n  const [viewingOrder, setViewingOrder] = useState<Order | null>(null);\n\n  const handleCancelOrder = (order: Order) => {\n    Modal.confirm({\n        title: 'ยืนยันการยกเลิก',\n        content: `คุณต้องการยกเลิกออเดอร์ ${order.id.substring(0, 8)} หรือไม่?`,\n        onOk: async () => {\n            try {\n                // Use Proxy API for update status\n                const response = await fetch(`/api/orders/${order.id}/status`, {\n                    method: 'PUT',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ status: OrderStatus.CANCELLED })\n                });\n\n                if (!response.ok) {\n                    throw new Error(\"Failed to cancel order\");\n                }\n                \n                message.success(\"ยกเลิกออเดอร์สำเร็จ\");\n            } catch (error) {\n                message.error(\"ยกเลิกออเดอร์ล้มเหลว\");\n            }\n        }\n    });\n  };\n\n  const columns = [\n    // ... existing columns ...\n    // {\n    //   title: 'Order ID',\n    //   dataIndex: 'id',\n    //   key: 'id',\n    //   render: (id: string) => <Text copyable>{id.substring(0, 8)}</Text>,\n    // },\n    {\n        title: 'ผู้สั่ง',\n        dataIndex: ['ordered_by', 'username'],\n        key: 'ordered_by',\n        render: (text: string) => text || 'Unknown',\n    },\n    {\n      title: 'รายการสินค้า',\n      dataIndex: 'ordersItems',\n      key: 'items',\n      render: (items: any[]) => ( // eslint-disable-line @typescript-eslint/no-explicit-any\n        <Space direction=\"vertical\">\n          {(items || []).map((item) => (\n            <div key={item.id}>\n              <Text strong>{item.ingredient?.display_name}</Text>\n              <Text type=\"secondary\" style={{ marginLeft: 8 }}>\n                 x {item.quantity_ordered} {item.ingredient?.unit?.display_name}\n              </Text>\n            </div>\n          ))}\n        </Space>\n      ),\n    },\n    {\n      title: 'สถานะ',\n      dataIndex: 'status',\n      key: 'status',\n      render: (status: OrderStatus) => {\n        let color = 'default';\n        if (status === OrderStatus.PENDING) color = 'gold';\n        if (status === OrderStatus.COMPLETED) color = 'green';\n        if (status === OrderStatus.CANCELLED) color = 'red';\n        return <Tag color={color}>{status.toUpperCase()}</Tag>;\n      },\n    },\n    {\n      title: 'วันที่สั่ง',\n      dataIndex: 'create_date',\n      key: 'create_date',\n      render: (date: string) => new Date(date).toLocaleString('th-TH'),\n    },\n    {\n        title: 'จัดการ',\n        key: 'actions',\n        render: (_: unknown, record: Order) => (\n            <Space>\n                <Button \n                    size=\"small\" \n                    icon={<EyeOutlined />} \n                    onClick={() => setViewingOrder(record)}\n                >\n                    ดู\n                </Button>\n                {(user?.role === 'Admin' || user?.role === 'Manager') && (\n                <Button\n                    type=\"primary\"\n                    size=\"small\"\n                    style={{ backgroundColor: '#52c41a', borderColor: '#52c41a' }}\n                    icon={<ShoppingCartOutlined />}\n                    disabled={record.status !== OrderStatus.PENDING}\n                    onClick={() => router.push(`/buying?orderId=${record.id}`)}\n                >\n                    สั่งซื้อ\n                </Button>\n                )}\n                <Button \n                    type=\"primary\" \n                    ghost \n                    size=\"small\" \n                    icon={<EditOutlined />} \n                    disabled={record.status !== OrderStatus.PENDING}\n                    onClick={() => setEditingOrder(record)}\n                >\n                    แก้ไข\n                </Button>\n                <Button \n                    danger \n                    size=\"small\" \n                    icon={<StopOutlined />} \n                    disabled={record.status !== OrderStatus.PENDING}\n                    onClick={() => handleCancelOrder(record)}\n                >\n                    ยกเลิก\n                </Button>\n            </Space>\n        )\n    }\n  ];\n\n  return (\n    <div style={{ padding: 24, paddingBottom: 100 }}>\n        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 24 }}>\n            <Title level={2} style={{ margin: 0 }}>รายการสั่งซื้อ (รอการซื้อ)</Title>\n            <Button icon={<ReloadOutlined />} onClick={fetchOrders}>Refresh</Button>\n        </div>\n      \n      <Card loading={loading}>\n        <Table \n            dataSource={orders} \n            columns={columns} \n            rowKey=\"id\" \n            scroll={{ x: 800 }}\n            pagination={{ pageSize: 10 }}\n        />\n      </Card>\n\n      <EditOrderModal \n        open={!!editingOrder} \n        order={editingOrder} \n        onClose={() => setEditingOrder(null)} \n        onSuccess={fetchOrders}\n      />\n      \n      <OrderDetailModal\n        open={!!viewingOrder}\n        order={viewingOrder}\n        onClose={() => setViewingOrder(null)}\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"E:\\STEDD\\Order-Project-Frontend\\src\\app\\(main)\\page.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":40,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1222,1225],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1222,1225],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\n\nimport React, { useEffect, useState } from \"react\";\nimport axios from \"axios\";\nimport { \n  Layout, \n  Typography, \n  Spin, \n  Result,\n  List,\n  theme as antTheme,\n  message\n} from \"antd\";\nimport IngredientCard from \"@/components/IngredientCard\";\nimport CartDrawer from \"@/components/CartDrawer\";\nimport { Ingredients } from \"@/types/api/ingredients\";\nimport { useSocket } from \"@/hooks/useSocket\";\n\nconst { Content } = Layout;\nconst { Title } = Typography;\nconst { useToken } = antTheme;\n\nexport default function HomePage() {\n  const { token } = useToken();\n  const [ingredients, setIngredients] = useState<Ingredients[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const { socket } = useSocket();\n\n  useEffect(() => {\n    const fetchIngredients = async () => {\n      try {\n        setLoading(true);\n        const response = await axios.get(\"/api/ingredients/getAll\");\n        const allIngredients: Ingredients[] = response.data;\n        // Filter active ingredients\n        const activeIngredients = allIngredients.filter(item => item.is_active);\n        setIngredients(activeIngredients);\n        setError(null);\n      } catch (error: any) {\n        console.error(\"Error fetching ingredients:\", error);\n        setError(\"Failed to load ingredients. Please try again later.\");\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchIngredients();\n  }, []);\n\n  useEffect(() => {\n    if (!socket) return;\n\n    const onIngredientCreate = (newItem: Ingredients) => {\n      if (newItem.is_active) {\n        setIngredients((prev) => [newItem, ...prev]);\n        message.info(`New ingredient added: ${newItem.display_name}`);\n      }\n    };\n\n    const onIngredientUpdate = (updatedItem: Ingredients) => {\n      setIngredients((prev) => {\n        const exists = prev.find(item => item.id === updatedItem.id);\n        \n        if (updatedItem.is_active) {\n          if (exists) {\n            // Update existing\n            return prev.map(item => item.id === updatedItem.id ? updatedItem : item);\n          } else {\n            // Add if it became active and wasn't in list\n            return [updatedItem, ...prev];\n          }\n        } else {\n          // Remove if it became inactive\n          return prev.filter(item => item.id !== updatedItem.id);\n        }\n      });\n    };\n\n    const onIngredientDelete = ({ id }: { id: string }) => {\n      setIngredients((prev) => prev.filter((item) => item.id !== id));\n    };\n\n    socket.on('ingredients:create', onIngredientCreate);\n    socket.on('ingredients:update', onIngredientUpdate);\n    socket.on('ingredients:delete', onIngredientDelete);\n\n    return () => {\n      socket.off('ingredients:create', onIngredientCreate);\n      socket.off('ingredients:update', onIngredientUpdate);\n      socket.off('ingredients:delete', onIngredientDelete);\n    };\n  }, [socket]);\n\n  return (\n    <Layout style={{ minHeight: \"100vh\", background: token.colorBgContainer }}>\n      <Content style={{ padding: '24px', maxWidth: 1200, margin: '0 auto', width: '100%' }}>\n        <Title level={2} style={{ marginBottom: 24, textAlign: 'center' }}>\n          วัตถุดิบ\n        </Title>\n        \n        {loading ? (\n           <div style={{ textAlign: 'center', padding: 80 }}>\n             <Spin size=\"large\" />\n           </div>\n        ) : error ? (\n          <Result\n            status=\"error\"\n            title=\"Overview Failed\"\n            subTitle={error}\n          />\n        ) : (\n          <List\n            grid={{\n              gutter: 24,\n              xs: 1,  // 1 column on mobile\n              sm: 1,\n              md: 2,\n              lg: 3,  // 3 columns on desktop (large screens)\n              xl: 3,\n              xxl: 3,\n            }}\n            dataSource={ingredients}\n            renderItem={(item) => (\n              <List.Item>\n                <IngredientCard ingredient={item} />\n              </List.Item>\n            )}\n            locale={{ emptyText: \"No active ingredients found\" }}\n          />\n        )}\n      </Content>\n      <CartDrawer />\n    </Layout>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"E:\\STEDD\\Order-Project-Frontend\\src\\components\\IngredientCard.tsx","messages":[{"ruleId":"@next/next/no-img-element","severity":1,"message":"Using `<img>` could result in slower LCP and higher bandwidth. Consider using `<Image />` from `next/image` to automatically optimize images. This may incur additional usage or cost from your provider. See: https://nextjs.org/docs/messages/no-img-element","line":26,"column":13,"nodeType":"JSXOpeningElement","endLine":37,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { Card, Typography, Button, message } from 'antd';\nimport { ShoppingCartOutlined } from '@ant-design/icons';\nimport { Ingredients } from '@/types/api/ingredients';\nimport { useCart } from '@/contexts/CartContext';\n\nconst { Title, Paragraph } = Typography;\n\ninterface IngredientCardProps {\n  ingredient: Ingredients;\n}\n\nconst IngredientCard: React.FC<IngredientCardProps> = ({ ingredient }) => {\n  const { addToCart } = useCart();\n\n  const handleAddToCart = () => {\n    addToCart(ingredient);\n    message.success(`Added ${ingredient.display_name} to cart`);\n  };\n\n  return (\n    <Card\n      hoverable\n      cover={\n        <div style={{ position: 'relative', paddingTop: '56.25%', overflow: 'hidden' }}>\n            <img\n            alt={ingredient.display_name}\n            src={ingredient.img_url || 'https://placehold.co/600x400?text=No+Image'}\n            style={{\n                position: 'absolute',\n                top: 0,\n                left: 0,\n                width: '100%',\n                height: '100%',\n                objectFit: 'cover',\n            }}\n            />\n        </div>\n      }\n      style={{ width: '100%', borderRadius: 12, overflow: 'hidden' }}\n      bodyStyle={{ padding: '16px', display: 'flex', flexDirection: 'column', height: '100%' }}\n      actions={[\n        <Button \n            key=\"add\" \n            type=\"primary\" \n            icon={<ShoppingCartOutlined />} \n            onClick={handleAddToCart}\n            block\n            style={{ margin: '0 16px' }}\n        >\n            เพิ่มลงตะกร้า\n        </Button>\n      ]}\n    >\n      <div style={{ marginBottom: 8, flexGrow: 1 }}>\n        <Title level={4} style={{ margin: 0, lineHeight: 1.2 }}>\n            {ingredient.display_name}\n        </Title>\n        {ingredient.ingredient_name && (\n            <Typography.Text type=\"secondary\" style={{ fontSize: '12px' }}>\n                {ingredient.ingredient_name}\n            </Typography.Text>\n        )}\n      \n        <Paragraph \n            ellipsis={{ rows: 2, expandable: false, symbol: '...' }} \n            style={{ marginTop: 8, marginBottom: 0, minHeight: '44px', color: '#666' }}\n        >\n            {ingredient.description || '-'}\n        </Paragraph>\n      </div>\n    </Card>\n  );\n};\n\nexport default IngredientCard;\n","usedDeprecatedRules":[]},{"filePath":"E:\\STEDD\\Order-Project-Frontend\\src\\contexts\\SocketContext.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'socket'. Either include it or remove the dependency array.","line":55,"column":6,"nodeType":"ArrayExpression","endLine":55,"endColumn":12,"suggestions":[{"desc":"Update the dependencies array to be: [socket, user]","fix":{"range":[1411,1417],"text":"[socket, user]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\n\nimport React, { createContext, useEffect, useState, ReactNode } from \"react\";\nimport { io, Socket } from \"socket.io-client\";\n\ninterface SocketContextType {\n  socket: Socket | null;\n  isConnected: boolean;\n}\n\nexport const SocketContext = createContext<SocketContextType>({\n  socket: null,\n  isConnected: false,\n});\n\nimport { useAuth } from \"./AuthContext\";\n\nexport const SocketProvider = ({ children }: { children: ReactNode }) => {\n  const [socket, setSocket] = useState<Socket | null>(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const { user } = useAuth();\n\n  useEffect(() => {\n    if (!user) {\n        if (socket) {\n            socket.disconnect();\n            setSocket(null);\n            setIsConnected(false);\n        }\n        return;\n    }\n\n    // connect to backend\n    const socketUrl = process.env.NEXT_PUBLIC_BACKEND_API || \"http://localhost:3000\";\n    const socketInstance = io(socketUrl, {\n        transports: [\"websocket\"], \n        withCredentials: true, // Important: Send cookies for auth\n    });\n\n    socketInstance.on(\"connect\", () => {\n      console.log(\"Socket Connected:\", socketInstance.id);\n      setIsConnected(true);\n    });\n\n    socketInstance.on(\"disconnect\", () => {\n      console.log(\"Socket Disconnected\");\n      setIsConnected(false);\n    });\n\n    setSocket(socketInstance);\n\n    return () => {\n      socketInstance.disconnect();\n    };\n  }, [user]);\n\n  return (\n    <SocketContext.Provider value={{ socket, isConnected }}>\n      {children}\n    </SocketContext.Provider>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"E:\\STEDD\\Order-Project-Frontend\\src\\hooks\\useAsyncAction.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1155,1158],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1155,1158],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback } from \"react\";\nimport { useGlobalLoading } from \"../contexts/GlobalLoadingContext\";\nimport { Modal } from \"antd\";\n\n/**\n * Hook to wrap async actions with the global loading overlay.\n */\nexport const useAsyncAction = () => {\n    const { showLoading, hideLoading } = useGlobalLoading();\n\n    const execute = useCallback(async <T>(\n        action: () => Promise<T>,\n        loadingMessage: string = \"กำลังดำเนินการ...\",\n        successMessage?: string,\n        errorMessage: string = \"เกิดข้อผิดพลาด\"\n    ): Promise<T | undefined> => {\n        try {\n            showLoading(loadingMessage);\n            const result = await action();\n\n            // Wait a bit to ensure the loading state is perceived (optional, sometimes good for UX)\n            // await new Promise(resolve => setTimeout(resolve, 300));\n\n            if (successMessage) {\n                // Ideally use Antd message or notification, but for now we just return\n                // The caller might want to show success message\n                // Or we can integrate message.success here if we import it\n            }\n            return result;\n        } catch (error: any) {\n            console.error(\"Async action error:\", error);\n            Modal.error({\n                title: 'ข้อผิดพลาด',\n                content: error.message || errorMessage,\n            });\n            // throw error; // Optionally re-throw if caller needs to handle it too\n            return undefined;\n        } finally {\n            hideLoading();\n        }\n    }, [showLoading, hideLoading]);\n\n    return { execute };\n};\n","usedDeprecatedRules":[]},{"filePath":"E:\\STEDD\\Order-Project-Frontend\\src\\services\\auth.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":21,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[685,688],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[685,688],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios from \"axios\";\nimport { PROXY_CONFIGS } from \"../lib/proxy-utils\";\nimport { LoginCredentials, LoginResponse, User } from \"../types/api/auth\";\n\nconst API_URL = PROXY_CONFIGS.API_BASE_URL;\n\n// Create axios instance with credentials enabled\nconst api = axios.create({\n    baseURL: API_URL,\n    withCredentials: true, // Important for cookies\n    headers: {\n        \"Content-Type\": \"application/json\",\n    },\n});\n\nexport const authService = {\n    login: async (credentials: LoginCredentials): Promise<User> => {\n        try {\n            const response = await api.post<LoginResponse>(\"/auth/login\", credentials);\n            return response.data.user;\n        } catch (error: any) {\n            throw new Error(error.response?.data?.message || \"เข้าสู่ระบบไม่สำเร็จ\");\n        }\n    },\n\n    logout: async (): Promise<void> => {\n        try {\n            await api.post(\"/auth/logout\");\n        } catch (error) {\n            console.error(\"Logout failed\", error);\n        }\n    },\n\n    getMe: async (): Promise<User> => {\n        try {\n            const response = await api.get<User>(\"/auth/me\");\n            return response.data;\n        } catch (error) {\n            throw error;\n        }\n    }\n};\n","usedDeprecatedRules":[]},{"filePath":"E:\\STEDD\\Order-Project-Frontend\\src\\services\\orders.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[313,316],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[313,316],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Order, OrderStatus } from \"../types/api/orders\";\nimport { OrdersDetail } from \"../types/api/ordersDetail\";\nimport { getProxyUrl } from \"../lib/proxy-utils\";\n\nconst BASE_PATH = \"/orders\";\n\nconst getHeaders = (cookie?: string, contentType: string = \"application/json\"): HeadersInit => {\n    const headers: any = {};\n    if (contentType) headers[\"Content-Type\"] = contentType;\n    if (cookie) headers.Cookie = cookie;\n    return headers;\n};\n\nexport const ordersService = {\n    // Order Flow\n    createOrder: async (data: {\n        ordered_by_id: string;\n        items: { ingredient_id: string; quantity_ordered: number }[];\n        remark?: string;\n    }, cookie?: string): Promise<Order> => {\n        const url = getProxyUrl(\"POST\", BASE_PATH);\n        const headers = getHeaders(cookie);\n\n        const response = await fetch(url!, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(data),\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(() => ({}));\n            throw new Error(errorData.error || errorData.message || \"ไม่สามารถสร้างออเดอร์ได้\");\n        }\n        return response.json();\n    },\n\n    getAllOrders: async (cookie?: string): Promise<Order[]> => {\n        const url = getProxyUrl(\"GET\", BASE_PATH);\n        const headers = getHeaders(cookie, \"\");\n\n        const response = await fetch(url!, {\n            cache: \"no-store\",\n            headers\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(() => ({}));\n            throw new Error(errorData.error || errorData.message || \"ไม่สามารถดึงข้อมูลออเดอร์ได้\");\n        }\n        return response.json();\n    },\n\n    getOrderById: async (id: string, cookie?: string): Promise<Order> => {\n        const url = getProxyUrl(\"GET\", `${BASE_PATH}/${id}`);\n        const headers = getHeaders(cookie, \"\");\n\n        const response = await fetch(url!, {\n            cache: \"no-store\",\n            headers\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(() => ({}));\n            throw new Error(errorData.error || errorData.message || \"ไม่สามารถดึงข้อมูลออเดอร์ได้\");\n        }\n        return response.json();\n    },\n\n    updateStatus: async (id: string, status: OrderStatus, cookie?: string): Promise<Order> => {\n        const url = getProxyUrl(\"PUT\", `${BASE_PATH}/${id}/status`);\n        const headers = getHeaders(cookie);\n\n        const response = await fetch(url!, {\n            method: \"PUT\",\n            headers,\n            body: JSON.stringify({ status }),\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(() => ({}));\n            throw new Error(errorData.error || errorData.message || \"ไม่สามารถอัปเดตสถานะออเดอร์ได้\");\n        }\n        return response.json();\n    },\n\n    updateOrder: async (id: string, items: { ingredient_id: string; quantity_ordered: number }[], cookie?: string): Promise<Order> => {\n        const url = getProxyUrl(\"PUT\", `${BASE_PATH}/${id}`);\n        const headers = getHeaders(cookie);\n\n        const response = await fetch(url!, {\n            method: \"PUT\",\n            headers,\n            body: JSON.stringify({ items }),\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`Failed to update order: ${response.status} ${errorText}`);\n        }\n        return response.json();\n    },\n\n    confirmPurchase: async (id: string, items: { ingredient_id: string; actual_quantity: number; is_purchased: boolean }[], purchased_by_id: string, cookie?: string): Promise<Order> => {\n        const url = getProxyUrl(\"POST\", `${BASE_PATH}/${id}/purchase`);\n        const headers = getHeaders(cookie);\n\n        const response = await fetch(url!, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify({ items, purchased_by_id }),\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`Failed to confirm purchase: ${response.status} ${errorText}`);\n        }\n        return response.json();\n    },\n    updatePurchaseDetail: async (data: {\n        orders_item_id: string;\n        actual_quantity: number;\n        purchased_by_id: string;\n        is_purchased?: boolean;\n    }, cookie?: string): Promise<OrdersDetail> => {\n        const url = getProxyUrl(\"POST\", \"/ordersDetail/update\");\n        const headers = getHeaders(cookie);\n\n        const response = await fetch(url!, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(data),\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(() => ({}));\n            throw new Error(errorData.error || errorData.message || \"ไม่สามารถอัปเดตข้อมูลการซื้อได้\");\n        }\n        return response.json();\n    },\n\n    deleteOrder: async (id: string, cookie?: string): Promise<void> => {\n        const url = getProxyUrl(\"DELETE\", `${BASE_PATH}/${id}`);\n        const headers = getHeaders(cookie, \"\");\n\n        const response = await fetch(url!, {\n            method: \"DELETE\",\n            headers\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`Failed to delete order: ${response.status} ${errorText}`);\n        }\n    },\n};\n","usedDeprecatedRules":[]}]